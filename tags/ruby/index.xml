<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ruby on Lab journal</title><link>http://labjournal.weburn.ru/tags/ruby/</link><description>Recent content in ruby on Lab journal</description><generator>Hugo -- gohugo.io</generator><language>ru</language><managingEditor>fpaint@gmail.com (Andrew)</managingEditor><webMaster>fpaint@gmail.com (Andrew)</webMaster><lastBuildDate>Sat, 10 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="http://labjournal.weburn.ru/tags/ruby/index.xml" rel="self" type="application/rss+xml"/><item><title>Матчер русских имён</title><link>http://labjournal.weburn.ru/post/2021-07-10-names-matcher/</link><pubDate>Sat, 10 Jul 2021 00:00:00 +0000</pubDate><author>fpaint@gmail.com (Andrew)</author><guid>http://labjournal.weburn.ru/post/2021-07-10-names-matcher/</guid><description>В одном проекте у меня возникла следующая задача: юзер вводит имя-фамилию в поле, а потом это значение надо выгрузить во внешнюю систему раздельно, в одно поле имя, а фамилию в другое. И понятно, что юзер может ввести по разному. Может первым словом имя указать, а может и вторым. Так что банальный split не прокатит. Стали думать, как эту задачу решать, поискали варианты, нашли питоновскую библиотечку natasha со списком из ~7тыс имён, подумывали выдрать список и применить, но в итоге забили и как-то обошлись.</description></item><item><title>module_function</title><link>http://labjournal.weburn.ru/post/2021-04-30-module_function/</link><pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate><author>fpaint@gmail.com (Andrew)</author><guid>http://labjournal.weburn.ru/post/2021-04-30-module_function/</guid><description>Узнал тут о замечательной фишке руби. Оказывается, можно делать модули, которые будут работать подобно классам с чистыми статическими функциями. Но обо всём по порядку.
Итак, в руби сильно ООП. Язык предполагает, что разработчики оформляют код в классы, и если есть какие-то данные, то их следует обернуть классом и обрабатывать методами этого класса, инстанциируя объекты. А модули там вроде как дополнительная фишка, для разграничения неймспейсов и организации миксинов. Чтоб, если какой класс станет слишком большим, можно было бы разнести его по модулям и потом собирать из кусочков.</description></item></channel></rss>
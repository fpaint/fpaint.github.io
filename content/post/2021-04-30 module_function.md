---
title: "module_function"
date: 2021-04-30
draft: false
tags: ['ruby']
---

Узнал тут о замечательной фишке руби. Оказывается, можно делать модули, которые будут работать подобно классам с чистыми статическими функциями. Но обо всём по порядку. 

Итак, в руби сильно ООП. Язык предполагает, что разработчики оформляют код в классы, и если есть какие-то данные, то их следует обернуть классом и обрабатывать методами этого класса, инстанциируя объекты. А модули там вроде как дополнительная фишка, для разграничения неймспейсов и организации миксинов. Чтоб, если какой класс станет слишком большим, можно было бы разнести его по модулям и потом собирать из кусочков. 

Иногда это удобно, иногда не очень. Иногда проще делать статические функции, которые не пользуются контекстом объекта, а получают всё, что им нужно, в аргументах. И тут возникала проблема. Методы классов по умолчанию принадлежат инстансу, и вызываются только у объектов. Чтобы делать их статическими, надо или объявлять их либо как `def self.method_name`, либо специальным синтаксисом `class << self`:

```ruby
  class MyClass
    class << self
      def static_method
        ...
      end
    end
  end        
```

А что же модули? Модули руби ведут себя не так, как модули в эликсире или расте. Почему-то по умолчанию вызывать функции, объявленные в модулях, нельзя. Сделать из модуля набор статических функций, не получится. Или всё таки можно? Оказывается, у модуля есть встроенная функция `module_function`, которая делает доступные снаружи методы из функций. Что-то типа такого:

```ruby
  module MyModule
    def static_function
      puts 'It works!'
    end
    module_function :static_function
  end

  MyModule.static_function
```

Плюс, если вызывать `module_function` без аргументов до объявления функциий, то они автоматически делаются доступными извне. 

```ruby
  module MyModule
    module_function

    def static_function
      puts 'It works!'
    end
  end
```


### extend self

А ещё есть другой способ сделать тоже самое. По некоторым [сведениям](https://www.mendelowski.com/docs/ruby/self-vs-extend-self-vs-module-function/) даже более правильный, чем `module_function`:

```ruby
  module MyModule
    extend self

    def static_function
      puts 'It works!'
    end
  end
```


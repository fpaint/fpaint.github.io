---
title: "Матчер русских имён"
date: 2021-07-10
draft: false
tags: ['ruby', 'regexp']
---
В одном проекте у меня возникла следующая задача: юзер вводит имя-фамилию в поле, а потом это значение надо выгрузить во внешнюю систему раздельно, в одно поле имя, а фамилию в другое. И понятно, что юзер может ввести по разному. Может первым словом имя указать, а может и вторым. Так что банальный split не прокатит. Стали думать, как эту задачу решать, поискали варианты, нашли питоновскую библиотечку [natasha](https://github.com/natasha/natasha) со списком из ~7тыс имён, подумывали выдрать список и применить, но в итоге забили и как-то обошлись. 

Тем не менее, задачка запала и породила незакрытый гештальт. Я задумался: а нельзя ли сделать не просто перебор со сравнением, а что-то вроде древовидного индекса? Типа, список разных начал строк, и к ним привязаны списки различных продолжений, и т.д. И чтоб по нему было можно быстро проверить, матчится ли строка. Следом подумал: если есть такой древовидный индекс, что мешает сделать из него регулярное выражение? Задача получается интересная, в духе codewars, на алгоритмы и деревья, при этом из реальной жизни. И когда выдалось свободное время, попробовал решить. Вот что получилось. 

Класс ноды, из которых собирается дерево индекса: 

```ruby 
class Node
  attr_accessor :str, :nodes, :final

  def initialize(str, nodes = [], final = false)
    @str = str      # подстрока ноды 
    @nodes = nodes  # список дочерних нод
    @final = final  # флажок, что строка, соответствующая ноде
                    # матчится даже если есть дочерние ноды 
  end

  # вычисляет количество первых совпавших символов у подстроки и str
  def match(str)
    i = 0
    i += 1 while(i < str.length && i < @str.length && str[i] == @str[i])
    i
  end

end
```

Самое интересное - функция, которая добавляет строку в индекс: 

```ruby
def push(nodes, str)
  match = 0
  node = nil
  # ищем ноду с максимальным совпадением начала
  nodes.each do |n|
    m = n.match(str)
    if m > match 
      match = m
      node = n
    end   
  end
  if(match == 0) # совсем уникальная строка, добавляем новой нодой целиком
    nodes.push Node.new(str)
  else
    # проверяем, и если нода финальная, ставим флажок
    node.final = true if node.str.length == match && 
      (node.nodes.length == 0 ? str.length > match : str.length == match)
    # при частичном совпадении делим ноду и переносим подноды в новую
    if node.str.length > match
      tail = node.str[match, 100]
      node.nodes = [Node.new(tail, node.nodes, node.final)]
      node.str = node.str[0, match]
    end
    # вызываем рекурсивно для остатка строки
    push(node.nodes, str[match, 100]) if str.length > match
  end
end
```

Функция, которая рекурсивно генерирует регулярное выражение из списка нод:

```ruby
def regexp(nodes)
  nodes.map{|n| n.str + 
    (n.nodes.length > 0 ? "(#{regexp(n.nodes)})#{n.final ? '?' : ''}" : '')}.join('|')
end
```

Тест:

```ruby
it 'should generate regexp' do
  nodes = []
  Names.push(nodes, 'корова')
  expect(Names.regexp(nodes)).to eq('корова')
  Names.push(nodes, 'корова')
  expect(Names.regexp(nodes)).to eq('корова')
  Names.push(nodes, 'корона')
  expect(Names.regexp(nodes)).to eq('коро(ва|на)')
  Names.push(nodes, 'корован')
  expect(Names.regexp(nodes)).to eq('коро(ва(н)?|на)')
  Names.push(nodes, 'котелок')
  expect(Names.regexp(nodes)).to eq('ко(ро(ва(н)?|на)|телок)')
end
```

Что получилось в итоге. Список имён в 97,4Кб сконвертировался в огромное регулярное выражение длиной 51Кб. Посмотреть его можно в [гисте](https://gist.github.com/fpaint/caacffdf1c3331a1fe01767b04c0bbab). Наверное, если где-то понадобится проверять имена очень быстро, миллионами за секунду, то эта регулярочка будет очень кстати. 

Иллюстрация:
![](/images/name_matcher.png)